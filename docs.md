Описание техпроцесса загрузки и отправки файлов с разграничением доступа:
1. В `main/models.py` размещается модель `File`. Данная модель имеет поле класса `FileField`, которое предназначено для
сохранения в него файла. Конструктор класса `FileField` имеет параметр `upload_to`, в который передается функция,
   возвращающая путь для сохранения файла.
   
2. Модуль `File` имеет полиморфную связь, благодаря которой данная модель связывается с другими моделями через внешний
ключ. Данное решение было выбрано, чтобы не создавать модель `File` для каждой модели, где возможна загрузка файла.
   
3. Метод get_file_path(), определенный в классе `File` возвращает путь для сохранения файла. Путь для сохранения
файла зависит от модели, связанной внешним ключом с `File`. Ссылка на класс связанной модели записана в атрибуте 
   `content_type`.
   
4. Сохранение файлов происходит в директорию, указанную в переменной `MEDIA_ROOT` из модуля `settings.py`.
По умолчанию это директория `data`, расположенная в корне Django проекта.

5. Для формирования ссылок на файлы используется путь, указанный в переменной `MEDIA_URL`, которая представляет
собой URL, указывающий на каталог с файлами `MEDIA_ROOT`. Данные ссылки будут использоваться для переходов по ним
   пользователей.
   
6. При переходе пользователя по ссылке, запрос будет смаршрутизирован на обработку функцией `check_file_permissions`,
которая проверит права пользователя на доступ к файлу. Если он не имеет прав доступа, будет возбуждено исключение
   `PermissionDenied`, пользователь получит в ответ HTTP 403. В случае наличия прав на доступ, пользователю будет
   отправлен файл, путь к которому будет сформирован путем конкатенации на основе переменной `SENDFILE_ROOT` (из модуля 
   `settings.py`) и пути к файлу (из HTTP запроса).
   
7. Django отправит к Nginx специально сформированный HTTP запрос, содержащий путь к файлу, сформированный на прошлом шаге,
   с заголовком `X-accel`. Nginx 'увидит', что запрос пришел от сервера localhost с заголовком `X-accel` и "отдаст" 
   файл пользователю.
   
8. Таким образом Django принимает запрос на загрузку файла, проверяет есть ли у пользователя права на доступ к данному
файлу. В случае наличия прав, подготавливает ответ, который обрабатывается Nginx. Nginx производит отдачу файла
   пользователю. В итоге: Django проверяет права, Nginx - выполняет работу по отдаче файла. Итог - каждый выполняет
   свою работу - ту, для которой он был создан.
   
9. В Nginx у нас имеется две директивы:
1) Общая ''. Для общего доступа к ресурсам портала.
2) /data с опцией private; Для доступа к директории с файлами только по запросу от сервера. Доступ к данной директории
возможен только с локального узла. Так же HTTP запрос должен содержать обязательный заголовок `X-accel`, содержащий
   путь к файлу, который требуется отдать пользователю.

10. Для загрузки файла пользователь обращается по пути, начинающемуся на /media, после обработки запроса он получает
файл, хранящийся по пути, начинающийся на /data. Это необходимо для корректной маршрутизации запросов пользователя к 
    файлам и ответов Django, содержащих путь к файлу.
    

Особенности обработки статичных файлов:
1. Для обработки статичных файлов (css, js, img. etc ...) не используется Django.
2. Вместо Django для отдачи статического контента используется Nginx с целью оптимизации производительности, т.к.
   Nginx лучше справляется с отдачей статического контента - он для этого и создавался.
3. Все статические файлы требуется добавлять в директорию `static`, расположенную в корне Django проекта.
4. В nginx добавлена директива 
```shell
location ~ ^\/static.+\.(css|png|svg|gif|js|woff) {
                        root /home/alexander/PycharmProjects/help_desk_2/help_desk;
                }
```
Которая отвечает за предоставление доступа к статическому контенту.
5. При добавлении в проект приложений, имеющих в своем составе статические файлы, их нужно копировать в директорию
`static` в корне проекта.
   
   
Используемая система разграничения доступа и логика ее работы:
1. В проекте в качестве системы разграничения доступа используется `django-guardian==2.4.0`.
2. Доступ к категориям и файлам предоставляется по следующей логике:
- Доступ к заявке, а так же ко всем файлам, добавленным в рамках текущей заявки предоставляется пользователю - автору заявки.
- Доступ к заявке, а так же ко всем файлам, добавленным в рамках текущей заявки предоставляется всем пользователям, состоязим в группе <название категории заявки>_admins.
3. В группе <название категории заявки>_admins состоят администраторы, ответственные за текущий раздел.
4. Администраторы в группы добавляются через административный интерфейс.
5. Добавление прав доступа к заявке, файлам осуществляется в процессе создания их экземпляров классов.

Дополнительная техническая информация по системе разграничения доступа:
1. Назначение прав доступа производится здесь:
```Python
from guardian.shortcuts import assign_perm

assign_perm(perm='view_ticket', user_or_group=request.user, obj=ticket)
            try:
                assign_perm(perm='view_ticket', user_or_group=Group.objects.
                            get(name=f'{ticket.category.codename}_admins'), obj=ticket)
```
2. Проверка прав производится здесь:
```Python
from guardian.core import ObjectPermissionChecker

ticket_obj = get_object_or_404(Ticket.objects.select_related('author', 'category', 'priority', 'status').
                                   prefetch_related('files'), pk=ticket_id)
    perm_checker = ObjectPermissionChecker(request.user)
    if not perm_checker.has_perm('view_ticket', ticket_obj):
        raise PermissionDenied
```

3. Группы администраторов для каждой категории заявок создаются при помощи сигнала `create_group`
4. Для хранения прав доступа используются таблицы БД `guardian_groupobjectpermission` и `guardian_userobjectpermission`
5. Система проверки прав доступа при большом количестве запросов к ресурсу может создавать значительное количество запросов к СУБД, создавая большую нагрузку (из-за применения в модели данной библиотеки поля `GenericForeignKey`). Это можно оптимизировать в документации к библиотеке описано как. По дефолту (при небольшом количестве пользователей), это не потребуется.
